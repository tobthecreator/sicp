Exercise 1.9.  Each of the following two procedures defines a method for adding two positive integers in terms of the procedures inc, which increments its argument by 1, and dec, which decrements its argument by 1.

(define (+ a b)
  (if (= a 0)
      b
      (inc (+ (dec a) b))))

(define (+ a b)
  (if (= a 0)
      b
      (+ (dec a) (inc b))))

Using the substitution model, illustrate the process generated by each procedure in evaluating (+ 4 5). Are these processes iterative or recursive?


// adding two positive integers

So this is redefining the addition function, +

// first one
(define (+ a b)
  (if (= a 0)
      b
      (inc (+ (dec a) b))))

(+ 4 5)
--> inc( + 3 5)
--|--> inc ( + 2 5)
--|--|--> inc (+ 1 5)
--|--|--|--> inc ( + 0 5)
--|--|--|--|--> 5
--|--|--|--> 6
--|--|--> 7
--|--> 8
--> 9
9

So that is definitely iterative recursive.

// second one
(define (+ a b)
  (if (= a 0)
      b
      (+ (dec a) (inc b))))

(+ 4 5)
--> + 3 6
--> + 2 7
--> + 1 8
--> + 0 9
--> 9

definitely linear iterative

glad i figured out a way to map these visually.


alright next one.

Exercise 1.10.  The following procedure computes a mathematical function called Ackermann's function.

(define (A x y)
  (cond ((= y 0) 0)
        ((= x 0) (* 2 y))
        ((= y 1) 2)
        (else (A (- x 1)
                 (A x (- y 1))))))

What are the values of the following expressions?

(A 1 10)

(A 2 4)

(A 3 3)

Consider the following procedures, where A is the procedure defined above:

(define (f n) (A 0 n))

(define (g n) (A 1 n))

(define (h n) (A 2 n))

(define (k n) (* 5 n n))

Give concise mathematical definitions for the functions computed by the procedures f, g, and h for positive integer values of n. For example, (k n) computes 5n2.


just going to run it first. 

;Value: a

1 ]=> (A 1 10)

;Value: 1024

1 ]=> (A 2 4)

;Value: 65536

1 ]=> (A 3 3)

;Value: 65536

1 ]=> 

okay let's type and explore

(  
    define (A x y)
    (
        cond
            // if y is 0, then 0
            ((= y 0 0))

            // if x is 0, then 2y
            ((= x 0) (* 2 y))

            // if y = 1, then 2
            ((= y 1) 2)

            // otherwise, run A again, with x decremented by 1 and y as the result of A with y decrement by 1
            (
                else (A (- x 1) (A x (- y 1)))
            )
    )

)

haha wtf

okay

(define (f n) (A 0 n))

(A 0 n)
--> y is not zero. x is. so this is just 2n and we're done. --> 2n.

(A 1 n)
--> (A 0 (A 1 (- n 1)))
--|--> now we have two of these to contend with.  
--|--> But we know that since x is 0, the second one will output 2y.  And 2y is the result of running A with (A 1 n-1) 
--|--> 2 * (A 1 n-1)
--|--|-->

0 for n=0, clearly

eventually it does just return 2 when n = 1

so 2^n? for anything that isn't 0

(A 2 n)

still 0 for n=0
2 for n=1

2^(2)^n?


Exercise 1.11.  A function f is defined by the rule that f(n) = n if n<3 and f(n) = f(n - 1) + 2f(n - 2) + 3f(n - 3) if n> 3. Write a procedure that computes f by means of a recursive process. Write a procedure that computes f by means of an iterative process.

f(n) = 3 if n < 3
f(n) = f(n-1) + 2*f(n-2) + 3*f(n-3) if n>=3

Write a recursive and then iterative process for this.

fuck 

okay

recursive doesn't seem toooooo bad.

(
    define
    (f n)
    (
        if (< n 3) 
            3
            (+ (f (- n 1)) (* 2 (f (- n 2))) (* 3 (f (- n 3))) )
    )
)

so let's not pretend i'm smart enough to intuit what I need to do to make this iterative

I know it has the same shape.

If this thing, then this simple answer. otherwise swap these variables around a bit

(
    define 
    (f n)
    (f-iter a b c n)
)


(
    define
    (f-iter a b c n)

)

so in the previosu one, it cycled through a <- b

and now we have 3 cycles.

a <- b <- c

let's assume the same n math sticks

so it's f-iter a b c count






















